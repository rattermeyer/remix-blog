= Remix eine Alternative für Geschäftsanwendungen

In diesem Blog will ich dir Remix als eine Alternative zur Entwicklung von Geschäftsanwendungen vorstellen.
Vor 10-15 Jahren noch war es üblich Geschäftsanwendungen mittels Server-seitigem Rendering zu entwickeln.
Das war die Zeit der klassischen Frameworks, wie PHP, Ruby on Rails, ASP.NET oder Java Server Faces.
Die Anwendungen wurden auf dem Server gerendert und als HTML an den Browser ausgeliefert.
Allerdings scheuten viele Entwickler die Komplexität von JavaScript und die damit verbundenen Probleme.
Die Browser waren damals noch nicht so standardisiert und performant wie heute.
Wobei man auch heute noch streiten kann, ob die Browser wirklich standardisiert sind.
Aber damals war es noch schlimmer.

// TODO: Mini-Architekturbild einfügen

Allerdings hatten diese Anwendungen gegenüber klassischen Desktop Anwendungen, die sie ablösen sollten, einen entscheidenden Nachteil.
Sie waren nicht so responsiv und interaktiv, wie klassische Desktop Anwendungen.
Das lag daran, dass die Anwendungen immer wieder den Server kontaktieren mussten, um Daten zu laden oder zu speichern.

Mit der Einführung von AJAX und später Single Page Applications (SPA) hat sich das geändert.
Die Anwendungen wurden interaktiver und responsiver.
Die Welt drehte sich komplett in Richtung Single Page Applications.

Die Kommunikation mit dem Server erfolgte über HTTP APIs, die Daten im JSON Format austauschten.
Die Anwendungen wurden im Browser gerendert und die Daten über APIs geladen.
Dies führte zu einem Push des REST Paradigmas.

// TODO: Mini-Architekturbild einfügen

Und aus meiner Sicht führte das zu ein paar Problemen, die erstmal nicht so offensichtlich waren, da alle auf den Zug aufgesprungen sind und es so gemacht haben.
Es waren auch alle damit beschäftigt, erst einmal die neuen Technologien zu lernen und zu verstehen.
Es kamen immer mehr SPA Frameworks auf: Angular 1, Angular, React, Vue.js, Svelte, Preact, ember, um nur ein paar zu nennen.
Außerdem kam neben JavaScript auch TypeScript auf, das die Sprache JavaScript um Typen erweiterte.
Und das Tooling drumherum war massiv in Bewegung: Webpack, Rollup, Babel, ESLint, Prettier, Jest, Cypress, Storybook, um nur ein paar zu nennen.

Aber so langsam wurden auch einige Probleme sichtbar bei der Benutzung von REST.
Es ist nicht so einfach bei einem REST Architekturstil die Daten so zu laden, wie das Frontend sie für einen bestimmten Use Case benötigt.
Es gibt Overfetching und Underfetching, also es werden zu viele oder zu wenige Daten vom Backend geladen.
Das Overfetching hat zur Folge, dass die Latenzzeit und gerade auch im mobilen Bereich die Datenmenge, die übertragen werden muss, steigt.
Underfetching hat zur Folge, dass mehrere Requests gemacht werden müssen, um die Daten zu laden, die für einen Use Case benötigt werden.
Dies erhöht die Latenzzeit und die Komplexität der Anwendung.
Gleichzeitig muss das Frontend wissen, welche Endpunkte es ansprechen muss, um die Daten zu laden.
Mit der Einführung von Microservices, ist dies häufig nicht mehr so einfach, da die Daten auf verschiedene Services verteilt sind.

Um das Problem zu lösen, gibt es verschiedene Lösungen.
Zum einen wurde je Frontend ein spezielles Backend entwickelt, welches die Daten so liefert, wie das Frontend sie benötigt.
Diese Lösung ist als https://bff-patterns.com["Backend for Frontend"] bekannt.

Eine andere Lösung ist die Einführung von GraphQL oder Falcor.
Diese Technologien erlauben es dem Frontend, die Daten zu laden, die es benötigt.
Hier hat sich klar GraphQL durchgesetzt.
Der GraphQL Server fungiert dabei häufig als Gateway zu den Microservices.
Das Frontend braucht nur noch den GraphQL Server ansprechen und bekommt die Daten, die es benötigt.

Wer ein Frontend auf mehrere Backend Microservices aufsetzen muss, ist immer noch mit dieser Technologie oder anderen Technologien, die das gleiche Problem lösen, gut beraten, wie etwa tRPC.

Allerdings wird diese Komplexität für viele Geschäftsanwendungen mit einer überschaubaren Nutzerbasis gar nicht benötigt.
Man würde gerne die Vorteile von Single Page Applications nutzen, aber nicht die Komplexität, die damit einhergeht.
Die Entwicklung solcher Anwendungen scheint damit zu teuer und zu komplex zu werden.

Vielleicht ist dies auch eine der Motivatoren für den Trend zu No-Code und Low-Code Plattformen.
Sie versprechen die Entwicklung solcher Anwendungen drastisch zu vereinfachen zu beschleunigen.
Aus meiner Sicht aber geht das auf Kosten der Flexibilität und der Kontrolle über die Anwendungen.
Es kommt zu einem starken Vendor Lock in.
Irgendwie erinnert mich das an die 90er Jahre und das Aufkommen von 4GL Sprachen.
Der Wechsel zu einer anderen Technologie kann schwierig und kostspielig werden.
Low-Code Plattformen sind sehr "opinionated" in der Art und Weise, wie Software entwickelt wird.
Sie bieten vorgefertigte Bausteine und Prozesse, welche die Entwicklung beschleunigen können, bei spezifischen Anforderungen aber an Grenzen stoßen können.
Häufig sind sie aus meiner Sicht ebenfalls ein Rückschritt in der Softwareentwicklung.
Wenige unterstützen sauberes Unit Testing und die Integration in CI/CD Pipelines.
Ebenfalls stellen wir immer wieder fest, dass die Entwicklungskosten gesenkt werden, aber die Gesamtkosten aufgrund von Lizenzkosten und Abo-Gebühren steigen.
Gerade, wenn dann die Nutzeranzahl steigt, kann es schnell teuer werden.
Aufgrund der hohen Abhängigkeit von den Plattformen, kann es auch schwierig werden, die Anwendung zu skalieren oder zu migrieren.
Gleichzeitig benötigt man für die Entwicklung dieser Anwendungen auch noch Entwickler, die sich mit der Plattform auskennen.
Die Plattformen sind also nicht so einfach zu bedienen, wie es auf den ersten Blick scheint.

Wenn aber an den Verkaufsargumenten für Low Code Plattformen etwas dran ist: Entwicklungsgeschwindigkeit und Entwicklungskosten zu senken, wir aber gleichzeitig keine Kompromisse bei Standard-Technologien und einem relativ un-opinionated Ansatz machen wollen, was gibt es für Alternativen?

Hier kommt Remix ins Spiel. Remix ist ein sogenanntes Fullstack Framework, welches auf React und React-Router aufsetzt.
https://nextjs.org[Next.js] ist der Platzhirsch im React Umfeld, aber auch für die anderen SPA Frameworks gibt es Fullstack Frameworks, wie https://nuxt.com[Nuxt.js] für Vue.js oder https://kit.svelte.dev[SvelteKit] für Svelte.
Nur für Angular ist das Angebot dünn.
Es gibt mit https://analogjs.org[Analog] ein Fullstack Framework, welches auf Angular aufsetzt, aber es ist noch nicht so ausgereift wie die anderen Frameworks.

Viele der Fullstack Frameworks motivieren sich über den Aspekt der Search-Engine-Optimierung (SEO).
Da HTML Seiten auf dem Server gerendert werden, sind diese Anwendungen für Suchmaschinen unter Umständen besser geeignet.
Dies ist sicherlich wichtig für Anwendungen, die öffentlich zugänglich sind und von Suchmaschinen indexiert werden sollen.
Für interne Anwendungen ist der SEO Aspekt weniger interessant.

Was wir aber wollen ist:

* Serverseitiger Zugriff auf Datenbanken
* Authentifizierung und Autorisierung
* Testbarkeit
* Integration von Front- und Backend, ohne dass wir uns um die Details kümmern müssen

Einiges davon wird schon durch das Node.js Ökosystem abgedeckt.
Aber gerade der letzte Punkt ist die Domäne der Fullstack Frameworks.
Dies wird als Hydration und Dehydration bezeichnet.

Für Geschäftsanwendungen ebenfalls häufig wichtig sind aus meiner Sicht zwei Dinge:

* Mächtige Tabellen
* Formulare und Validierung

Dies wird nicht von Remix bereitgestellt.

Für Tabellen setzen wir auf Mantine-React-Tables bzw. Material-React-Tables.
Diese Komponenten setzen wiederum auf der (headless) Tanstack Table auf.
Neben der (kommerziellen) https://www.ag-grid.com[ag-grid] Komponente ist das sicherlich eine der mächtigsten Tabellenkomponenten im React Umfeld.

Für Formulare und Validierung setzen wir auf remix-hook-form, eine kleine Erweiterung von react-hook-form.

Gibt es also keine Nachteile? Doch, die gibt es.
Der HTML Code wird initial auf dem Server gerendert wird, kann es zu Unterschieden zwischen Client und Server-seitigem HTML Code kommen.
Die Ursachen sind https://www.jacobparis.com/content/remix-hydration-errors[vielfältig].
Das ist aber nicht spezifisch für Remix, sondern für alle Fullstack Frameworks, oder auch generell für Server-seitiges Rendering von React Apps.
