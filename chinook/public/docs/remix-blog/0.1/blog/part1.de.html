<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Remix eine Alternative für Geschäftsanwendungen :: Remix-blog</title>
    <meta name="generator" content="Antora 3.1.9">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Remix-blog</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
<!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
-->
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="remix-blog" data-version="0.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Remix Blog</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Introduction</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Deutsch</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="part1.de.html">Remix</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Remix Blog</span>
    <span class="version">0.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Remix Blog</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">0.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Remix Blog</a></li>
    <li>Deutsch</li>
    <li><a href="part1.de.html">Remix</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="file:///Users/rat/devel/git/remix-blog/chinook/docs/modules/blog/pages/part1.de.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Remix eine Alternative für Geschäftsanwendungen</h1>
<div class="paragraph">
<p>In diesem Blog will ich dir Remix als eine Alternative zur Entwicklung von Geschäftsanwendungen vorstellen.
Vor 10-15 Jahren noch war es üblich Geschäftsanwendungen mittels Server-seitigem Rendering zu entwickeln.
Das war die Zeit der klassischen Frameworks, wie PHP, Ruby on Rails, ASP.NET oder Java Server Faces.
Die Anwendungen wurden auf dem Server gerendert und als HTML an den Browser ausgeliefert.
Allerdings scheuten viele Entwickler die Komplexität von JavaScript und die damit verbundenen Probleme.
Die Browser waren damals noch nicht so standardisiert und performant wie heute.
Wobei man auch heute noch streiten kann, ob die Browser wirklich standardisiert sind.
Aber damals war es noch schlimmer.</p>
</div>
<div class="paragraph">
<p>Allerdings hatten diese Anwendungen gegenüber klassischen Desktop Anwendungen, die sie ablösen sollten, einen entscheidenden Nachteil.
Sie waren nicht so responsiv und interaktiv, wie klassische Desktop Anwendungen.
Das lag daran, dass die Anwendungen immer wieder den Server kontaktieren mussten, um Daten zu laden oder zu speichern.</p>
</div>
<div class="paragraph">
<p>Mit der Einführung von AJAX und später Single Page Applications (SPA) hat sich das geändert.
Die Anwendungen wurden interaktiver und responsiver.
Die Welt drehte sich komplett in Richtung Single Page Applications.</p>
</div>
<div class="paragraph">
<p>Die Kommunikation mit dem Server erfolgte über HTTP APIs, die Daten im JSON Format austauschten.
Die Anwendungen wurden im Browser gerendert und die Daten über APIs geladen.
Dies führte zu einem Push des REST Paradigmas.</p>
</div>
<div class="paragraph">
<p>Und aus meiner Sicht führte das zu ein paar Problemen, die erstmal nicht so offensichtlich waren, da alle auf den Zug aufgesprungen sind und es so gemacht haben.
Es waren auch alle damit beschäftigt, erst einmal die neuen Technologien zu lernen und zu verstehen.
Es kamen immer mehr SPA Frameworks auf: Angular 1, Angular, React, Vue.js, Svelte, Preact, ember, um nur ein paar zu nennen.
Außerdem kam neben JavaScript auch TypeScript auf, das die Sprache JavaScript um Typen erweiterte.
Und das Tooling drumherum war massiv in Bewegung: Webpack, Rollup, Babel, ESLint, Prettier, Jest, Cypress, Storybook, um nur ein paar zu nennen.</p>
</div>
<div class="paragraph">
<p>Aber so langsam wurden auch einige Probleme sichtbar bei der Benutzung von REST.
Es ist nicht so einfach bei einem REST Architekturstil die Daten so zu laden, wie das Frontend sie für einen bestimmten Use Case benötigt.
Es gibt Overfetching und Underfetching, also es werden zu viele oder zu wenige Daten vom Backend geladen.
Das Overfetching hat zur Folge, dass die Latenzzeit und gerade auch im mobilen Bereich die Datenmenge, die übertragen werden muss, steigt.
Underfetching hat zur Folge, dass mehrere Requests gemacht werden müssen, um die Daten zu laden, die für einen Use Case benötigt werden.
Dies erhöht die Latenzzeit und die Komplexität der Anwendung.
Gleichzeitig muss das Frontend wissen, welche Endpunkte es ansprechen muss, um die Daten zu laden.
Mit der Einführung von Microservices, ist dies häufig nicht mehr so einfach, da die Daten auf verschiedene Services verteilt sind.</p>
</div>
<div class="paragraph">
<p>Um das Problem zu lösen, gibt es verschiedene Lösungen.
Zum einen wurde je Frontend ein spezielles Backend entwickelt, welches die Daten so liefert, wie das Frontend sie benötigt.
Diese Lösung ist als <a href="https://bff-patterns.com">"Backend for Frontend"</a> bekannt.</p>
</div>
<div class="paragraph">
<p>Eine andere Lösung ist die Einführung von GraphQL oder Falcor.
Diese Technologien erlauben es dem Frontend, die Daten zu laden, die es benötigt.
Hier hat sich klar GraphQL durchgesetzt.
Der GraphQL Server fungiert dabei häufig als Gateway zu den Microservices.
Das Frontend braucht nur noch den GraphQL Server ansprechen und bekommt die Daten, die es benötigt.</p>
</div>
<div class="paragraph">
<p>Wer ein Frontend auf mehrere Backend Microservices aufsetzen muss, ist immer noch mit dieser Technologie oder anderen Technologien, die das gleiche Problem lösen, gut beraten, wie etwa tRPC.</p>
</div>
<div class="paragraph">
<p>Allerdings wird diese Komplexität für viele Geschäftsanwendungen mit einer überschaubaren Nutzerbasis gar nicht benötigt.
Man würde gerne die Vorteile von Single Page Applications nutzen, aber nicht die Komplexität, die damit einhergeht.
Die Entwicklung solcher Anwendungen scheint damit zu teuer und zu komplex zu werden.</p>
</div>
<div class="paragraph">
<p>Vielleicht ist dies auch eine der Motivatoren für den Trend zu No-Code und Low-Code Plattformen.
Sie versprechen die Entwicklung solcher Anwendungen drastisch zu vereinfachen zu beschleunigen.
Aus meiner Sicht aber geht das auf Kosten der Flexibilität und der Kontrolle über die Anwendungen.
Es kommt zu einem starken Vendor Lock in.
Irgendwie erinnert mich das an die 90er Jahre und das Aufkommen von 4GL Sprachen.
Der Wechsel zu einer anderen Technologie kann schwierig und kostspielig werden.
Low-Code Plattformen sind sehr "opinionated" in der Art und Weise, wie Software entwickelt wird.
Sie bieten vorgefertigte Bausteine und Prozesse, welche die Entwicklung beschleunigen können, bei spezifischen Anforderungen aber an Grenzen stoßen können.
Häufig sind sie aus meiner Sicht ebenfalls ein Rückschritt in der Softwareentwicklung.
Wenige unterstützen sauberes Unit Testing und die Integration in CI/CD Pipelines.
Ebenfalls stellen wir immer wieder fest, dass die Entwicklungskosten gesenkt werden, aber die Gesamtkosten aufgrund von Lizenzkosten und Abo-Gebühren steigen.
Gerade, wenn dann die Nutzeranzahl steigt, kann es schnell teuer werden.
Aufgrund der hohen Abhängigkeit von den Plattformen, kann es auch schwierig werden, die Anwendung zu skalieren oder zu migrieren.
Gleichzeitig benötigt man für die Entwicklung dieser Anwendungen auch noch Entwickler, die sich mit der Plattform auskennen.
Die Plattformen sind also nicht so einfach zu bedienen, wie es auf den ersten Blick scheint.</p>
</div>
<div class="paragraph">
<p>Wenn aber an den Verkaufsargumenten für Low Code Plattformen etwas dran ist: Entwicklungsgeschwindigkeit und Entwicklungskosten zu senken, wir aber gleichzeitig keine Kompromisse bei Standard-Technologien und einem relativ un-opinionated Ansatz machen wollen, was gibt es für Alternativen?</p>
</div>
<div class="paragraph">
<p>Hier kommt Remix ins Spiel. Remix ist ein sogenanntes Fullstack Framework, welches auf React und React-Router aufsetzt.
<a href="https://nextjs.org">Next.js</a> ist der Platzhirsch im React Umfeld, aber auch für die anderen SPA Frameworks gibt es Fullstack Frameworks, wie <a href="https://nuxt.com">Nuxt.js</a> für Vue.js oder <a href="https://kit.svelte.dev">SvelteKit</a> für Svelte.
Nur für Angular ist das Angebot dünn.
Es gibt mit <a href="https://analogjs.org">Analog</a> ein Fullstack Framework, welches auf Angular aufsetzt, aber es ist noch nicht so ausgereift wie die anderen Frameworks.</p>
</div>
<div class="paragraph">
<p>Viele der Fullstack Frameworks motivieren sich über den Aspekt der Search-Engine-Optimierung (SEO).
Da HTML Seiten auf dem Server gerendert werden, sind diese Anwendungen für Suchmaschinen unter Umständen besser geeignet.
Dies ist sicherlich wichtig für Anwendungen, die öffentlich zugänglich sind und von Suchmaschinen indexiert werden sollen.
Für interne Anwendungen ist der SEO Aspekt weniger interessant.</p>
</div>
<div class="paragraph">
<p>Was wir aber wollen ist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Serverseitiger Zugriff auf Datenbanken</p>
</li>
<li>
<p>Authentifizierung und Autorisierung</p>
</li>
<li>
<p>Testbarkeit</p>
</li>
<li>
<p>Integration von Front- und Backend, ohne dass wir uns um die Details kümmern müssen</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Einiges davon wird schon durch das Node.js Ökosystem abgedeckt.
Aber gerade der letzte Punkt ist die Domäne der Fullstack Frameworks.
Dies wird als Hydration und Dehydration bezeichnet.</p>
</div>
<div class="paragraph">
<p>Für Geschäftsanwendungen ebenfalls häufig wichtig sind aus meiner Sicht zwei Dinge:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mächtige Tabellen</p>
</li>
<li>
<p>Formulare und Validierung</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dies wird nicht von Remix bereitgestellt.</p>
</div>
<div class="paragraph">
<p>Für Tabellen setzen wir auf Mantine-React-Tables bzw. Material-React-Tables.
Diese Komponenten setzen wiederum auf der (headless) Tanstack Table auf.
Neben der (kommerziellen) <a href="https://www.ag-grid.com">ag-grid</a> Komponente ist das sicherlich eine der mächtigsten Tabellenkomponenten im React Umfeld.</p>
</div>
<div class="paragraph">
<p>Für Formulare und Validierung setzen wir auf remix-hook-form, eine kleine Erweiterung von react-hook-form.</p>
</div>
<div class="paragraph">
<p>Gibt es also keine Nachteile? Doch, die gibt es.
Der HTML Code wird initial auf dem Server gerendert wird, kann es zu Unterschieden zwischen Client und Server-seitigem HTML Code kommen.
Die Ursachen sind <a href="https://www.jacobparis.com/content/remix-hydration-errors">vielfältig</a>.
Das ist aber nicht spezifisch für Remix, sondern für alle Fullstack Frameworks, oder auch generell für Server-seitiges Rendering von React Apps.</p>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>
  </body>
</html>
